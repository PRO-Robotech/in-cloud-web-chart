# --- Dependency ----------------------------------------------------------------
incloud-web-resources:
  enabled: true
  addons:
    argocd:
      enabled: false
    hbf:
      enabled: false
    trivy:
      enabled: false

oauth2-proxy:
  enabled: true
  priorityClassName: system-cluster-critical
  config:
    # OAuth Client ID and Client Secret issued by the identity provider (e.g., Dex, Keycloak, Google)
    clientID: "XXXXX"
    clientSecret: "YYYYY"
    # Secret used to encrypt cookies. Must be a cryptographically strong value
    # Create a new secret with the following command
    # openssl rand -base64 32 | head -c 32 | base64
    cookieSecret: "ZZZZZ"

  extraArgs:
    # Authentication provider type (e.g., oidc, google, github)
    provider: oidc

    # Display name shown on the login page for the provider
    provider-display-name: Dex

    # The backend application to proxy to after authentication
    # Replace SVC and PORT with your internal Kubernetes service and port
    upstream: "http://SVC:PORT"

    # Callback URL where the identity provider redirects after login
    # Must match the redirect URI configured in your IDP
    redirect-url: "https://DOMAIN/oauth2/callback"

    # Root URL of the OIDC identity provider (issuer)
    # Should point to your IDP (e.g., Dex, Keycloak, Auth0)
    oidc-issuer-url: "https://IDP_DOMAIN"

    # Restrict login to specific email domains. Use "*" to allow all domains
    # Example: "example.com" only allows users with @example.com
    email-domain: "*"

    # Forward the OAuth access token to the upstream application
    # Passed in the 'X-Forwarded-Access-Token' header
    pass-access-token: true

    # Forward the Authorization header (e.g., Bearer token) to the upstream
    # Useful if the backend application validates the token itself
    pass-authorization-header: true

    # How often to refresh the session cookie and revalidate the user
    # Helps maintain active sessions without forcing re-login
    cookie-refresh: 1h

    # Name of the cookie used to store the authentication session
    # Should be unique if multiple apps use the same domain
    cookie-name: incloud

    # Set the Secure flag on cookies — only send over HTTPS
    # Should be true in production environments
    cookie-secure: false

    # Skip SSL/TLS certificate verification when connecting to the upstream provider or OIDC issuer
    # WARNING: This disables security checks for HTTPS connections and accepts any certificate, including invalid or self-signed ones
    # Only use in trusted development or testing environments — NEVER in production
    # Default: false (recommended for secure deployments)
    ssl-insecure-skip-verify: true

    # Scopes requested from the identity provider
    # Uncomment and customize if you need specific claims (e.g., groups)
    # scope: "openid email profile groups offline_access"

    # Skip showing the provider login button; redirect directly to IDP
    # Enables seamless single sign-on experience
    skip-provider-button: true

    # OIDC prompt parameter. 'none' avoids login screen if session exists
    # Enables silent authentication when possible
    prompt: none

    # URL prefix for oauth2-proxy endpoints (e.g., /oauth2/callback, /oauth2/sign_in)
    proxy-prefix: /oauth2

  service:
    portNumber: 80

# --- Global ----------------------------------------------------------------
nameOverride: ""                  # Overrides chart name; leave empty to use default
fullnameOverride: "" # Overrides full release name; leave empty to use default

# Number of pod replicas
replicaCount: 1

# Pull secrets for private registries
imagePullSecrets: []               # e.g. [{ name: regcred }]

# Priority class for the pod
priorityClassName: system-cluster-critical

# --- ServiceAccount --------------------------------------------------------
serviceAccount:
  create: true
  name: ""                         # Defaults to <release>-<chart>
  annotations: {}

# --- Pod-level settings ----------------------------------------------------
podAnnotations: {}
podLabels: {}
podSecurityContext:
  enabled: true
  fsGroup: 101
  fsGroupChangePolicy: "OnRootMismatch"

# Node placement settings
nodeSelector: {}
tolerations: []
topologySpreadConstraints: []

# Networking-related pod spec
dnsPolicy: ClusterFirst
hostNetwork: false
hostPID: false
hostIPC: false
schedulerName: default-scheduler
runtimeClassName: ""
enableServiceLinks: false
preemptionPolicy: ""

# Volumes (user-defined; appended with nginx config if enabled)
volumes: []

# --- Service ---------------------------------------------------------------
service:
  enabled: true
  type: ClusterIP
  annotations: {}
  labels: {}
  ports:
    - name: web-http
      port: 8080
      targetPort: 8080
      protocol: TCP
    - name: nginx-http
      port: 80
      targetPort: 8081
      protocol: TCP
    - name: bff-http
      port: 8082
      targetPort: 8082
      protocol: TCP

ingress:
  enabled: true
  # resourceType: allowed values [istio, ingress]
  resourceType: ingress

  ingress:
    annotations: {}
    labels: {}
    ingressClassName: ""

  istio:
    gateway:
      enabled: true
      name: incloud-istio-gateway
      istioLabelsSelector: {} # required value!
        # istio: istio-ingressgateway
      annotations: {}
      labels: {}
    virtualService:
      annotations: {}
      labels: {}

  path: /
  # servicePort
  # if oauth2-proxy.enabled == true, set oauth2-proxy port
  # if oauth2-proxy.enabled == false, set incloud-web port
  servicePort: 80
  host: incloud.example.com
  tls:
    # The source of the tls certificate. Set as "auto", "secret"
    # or "none" and fill the information in the corresponding section
    # 1) auto: generate the tls certificate automatically over CertManager
    # 2) secret: read the tls certificate from the specified secret.
    # The tls certificate can be generated manually or by cert manager
    # 3) none: configure no tls certificate for the ingress. If the default
    # tls certificate is configured in the ingress controller, choose this option
    certSource: none
    secret:
      # The name of secret which contains keys named:
      # "tls.crt" - the certificate
      # "tls.key" - the private key
      secretName: ""

# --- Container: bff --------------------------------------------------------
bff:
  enabled: true
  name: bff
  image:
    repository: prorobotech/openapi-ui-k8s-bff
    tag: main-24cfd47b
    pullPolicy: IfNotPresent
  containerPort: 8082
  extraContainerPorts: []
  env:
    BASE_API_GROUP: "front.in-cloud.io"
    BASE_API_VERSION: "v1alpha1"
    DEBUG_CONTAINER_IMAGE: "nicolaka/netshoot:v0.13"
    LOGGER: "TRUE"
    LOGGER_WITH_HEADERS: "TRUE"
    PORT: "8082"
    KUBE_API_URL: https://kubernetes.default.svc
  envFrom: []
  resources:
    limits:
      cpu: "1"
      memory: 1Gi
    requests:
      cpu: 100m
      memory: 128Mi
      ephemeral-storage: 50Mi
  securityContext:
    enabled: true
    allowPrivilegeEscalation: false
    capabilities:
      add: ["CAP_CHOWN","CAP_NET_BIND_SERVICE","CAP_SETGID","CAP_SETUID"]
      drop: ["ALL"]
    privileged: false
    readOnlyRootFilesystem: false
    runAsGroup: 0
    runAsNonRoot: true
    runAsUser: 101
  livenessProbe:
    enabled: true
    httpGet:
      path: /healthcheck
      port: 8082
      scheme: HTTP
    initialDelaySeconds: 3
    periodSeconds: 10
    timeoutSeconds: 2
    successThreshold: 1
    failureThreshold: 3
  readinessProbe:
    enabled: false
    httpGet:
      path: /ready
      port: 8082
      scheme: HTTP
    initialDelaySeconds: 3
    periodSeconds: 10
    timeoutSeconds: 2
    successThreshold: 1
    failureThreshold: 3
  volumeMounts: []
  terminationMessagePath: /dev/termination-log
  terminationMessagePolicy: File

# --- Container: web --------------------------------------------------------
web:
  enabled: true
  name: web
  image:
    repository: prorobotech/openapi-ui
    tag: main-33c9d6dc
    pullPolicy: IfNotPresent
  containerPort: 8080
  extraContainerPorts: []
  env:
    BASEPREFIX: "/openapi-ui"
    CUSTOMIZATION_API_GROUP: "front.in-cloud.io"
    CUSTOMIZATION_API_VERSION: "v1alpha1"
    CUSTOMIZATION_NAVIGATION_RESOURCE: "navigation"
    CUSTOMIZATION_NAVIGATION_RESOURCE_NAME: "navigations"
    INSTANCES_API_GROUP: "in-cloud.io"
    INSTANCES_RESOURCE_NAME: "instances"
    INSTANCES_VERSION: "v1alpha1"
    LOGIN_URL: "/oauth2/sign_in"
    LOGIN_USERNAME_FIELD: "name"
    LOGOUT_URL: "/oauth2/sign_out"
    MARKETPLACE_GROUP: "front.in-cloud.io"
    MARKETPLACE_KIND: "MarketplacePanel"
    MARKETPLACE_RESOURCE_NAME: "marketplacepanels"
    MARKETPLACE_VERSION: "v1alpha1"
    NAVIGATE_FROM_CLUSTERLIST: "/openapi-ui/~recordValue~/builtin-table/pods"
    NODE_TERMINAL_DEFAULT_PROFILE: "general"
    PROJECTS_API_GROUP: "in-cloud.io"
    PROJECTS_RESOURCE_NAME: "projects"
    PROJECTS_VERSION: "v1alpha1"
    USE_NAMESPACE_NAV: true
    REMOVE_BACKLINK: true
    REMOVE_BACKLINK_TEXT: true
  envFrom: []
  resources:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi
      ephemeral-storage: 50Mi
  securityContext:
    enabled: true
    allowPrivilegeEscalation: false
    capabilities:
      add: ["CAP_CHOWN","CAP_NET_BIND_SERVICE","CAP_SETGID","CAP_SETUID"]
      drop: ["ALL"]
    privileged: false
    readOnlyRootFilesystem: false
    runAsGroup: 0
    runAsNonRoot: true
    runAsUser: 101
  livenessProbe:
    enabled: true
    httpGet:
      path: /healthcheck
      port: 8080
      scheme: HTTP
    initialDelaySeconds: 3
    periodSeconds: 10
    timeoutSeconds: 2
    successThreshold: 1
    failureThreshold: 3
  readinessProbe:
    enabled: false
    httpGet:
      path: /ready
      port: 8080
      scheme: HTTP
    initialDelaySeconds: 3
    periodSeconds: 10
    timeoutSeconds: 2
    successThreshold: 1
    failureThreshold: 3
  volumeMounts: []
  terminationMessagePath: /dev/termination-log
  terminationMessagePolicy: File

# --- Container: nginx (reverse proxy) --------------------------------------
nginx:
  enabled: true
  name: nginx
  image:
    repository: nginxinc/nginx-unprivileged
    tag: "1.29-alpine"
    pullPolicy: IfNotPresent
  containerPort: 8081
  extraContainerPorts: []
  configMapName: ""        # Defaults to "<fullname>-nginx-config"
  configKey: "nginx-config"
  env: {}
  envFrom: []
  resources:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 50m
      memory: 64Mi
      ephemeral-storage: 50Mi
  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    privileged: false
    readOnlyRootFilesystem: false
    runAsGroup: 0
    runAsNonRoot: true
    runAsUser: 101
    seccompProfile:
      type: RuntimeDefault
  livenessProbe:
    enabled: true
    httpGet:
      path: /healthcheck
      port: 8081
      scheme: HTTP
    initialDelaySeconds: 3
    periodSeconds: 10
    timeoutSeconds: 2
    successThreshold: 1
    failureThreshold: 3
  readinessProbe:
    enabled: false
    httpGet:
      path: /ready
      port: 8081
      scheme: HTTP
    initialDelaySeconds: 3
    periodSeconds: 10
    timeoutSeconds: 2
    successThreshold: 1
    failureThreshold: 3
  extraVolumeMounts: []
  terminationMessagePath: /dev/termination-log
  terminationMessagePolicy: File

# --- Labels/Selectors ------------------------------------------------------
selectorLabels:
  app.kubernetes.io/name: web

# --- Extra customizations --------------------------------------------------
extraPodSpec: {}
extraTemplateMetadata:
  annotations: {}
  labels: {}

extraObjects: []
